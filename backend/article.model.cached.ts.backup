// backend/src/models/article.model.cached.ts
import { Database } from 'better-sqlite3';
import { getDatabase } from '../config/database';
import { Article, PaginatedResponse, ArticleFilters } from '../types';
import { DatabaseError } from '../services/error.service';
import { cacheService } from '../services/cache.service';
import { logger } from '../utils/logger';

// Cache TTL configuration
const CACHE_TTL = {
  ARTICLE: 5 * 60 * 1000,      // 5 minutes
  LIST: 2 * 60 * 1000,         // 2 minutes
  STATS: 1 * 60 * 1000,        // 1 minute
};

export class CachedArticleModel {
  private db!: Database;

  constructor() {
    //this.db = getDatabase();
  }

  private getDb(): Database {
    if (!this.db) {
      this.db = getDatabase();
    }
    return this.db;
  }

  // Generate cache key for paginated queries
  private getCacheKey(prefix: string, filters: any): string {
    const filterStr = Object.entries(filters)
      .filter(([_, value]) => value !== undefined)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => `${key}:${value}`)
      .join('|');
    return `${prefix}:${filterStr}`;
  }

  // Create a new article
  create(article: Omit<Article, 'id' | 'createdAt' | 'updatedAt'>): Article {
    try {
      const stmt = this.getDb().prepare(`
        INSERT INTO articles (
          title, content, summary, description, excerpt, image_url, url, author, published_date, 
          source_id, is_read, is_favorite, is_archived
        ) VALUES (
          @title, @content, @summary, @description, @excerpt, @imageUrl, @url, @author, @publishedDate, 
          @sourceId, @isRead, @isFavorite, @isArchived
        )
      `);

      const info = stmt.run({
        title: article.title,
        content: article.content || null,
        summary: article.summary || null,
        description: article.description || null,
        excerpt: article.excerpt || null,
        imageUrl: article.imageUrl || null,
        url: article.url,
        author: article.author || null,
        publishedDate: article.publishedDate ? article.publishedDate.toISOString() : null,
        sourceId: article.sourceId,
        isRead: article.isRead ? 1 : 0,
        isFavorite: article.isFavorite ? 1 : 0,
        isArchived: article.isArchived ? 1 : 0
      });

      const newArticle = this.findById(Number(info.lastInsertRowid))!;
      
      // Invalidate related caches
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return newArticle;
    } catch (error) {
      throw new DatabaseError('Failed to create article', error);
    }
  }

  // Find article by ID with caching
  findById(id: number): Article | null {
    const cacheKey = `article:${id}`;
    
    // Check cache first
    const cached = cacheService.get<Article>(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      const stmt = this.getDb().prepare(`
        SELECT 
          a.*, 
          s.name as source_name, 
          s.url as source_url,
          s.category_id,
          c.name as category_name,
          c.color as category_color
        FROM articles a
        LEFT JOIN sources s ON a.source_id = s.id
        LEFT JOIN categories c ON s.category_id = c.id
        WHERE a.id = ?
      `);

      const row = stmt.get(id);
      const article = row ? this.mapRowToArticle(row) : null;
      
      // Cache the result
      if (article) {
        cacheService.set(cacheKey, article, CACHE_TTL.ARTICLE);
      }
      
      return article;
    } catch (error) {
      throw new DatabaseError('Failed to find article by ID', error);
    }
  }

  // Find all articles with pagination and filters - CACHED
  findAll(options: ArticleFilters & { page?: number; limit?: number } = {}): PaginatedResponse<Article> {
    const cacheKey = this.getCacheKey('articles:list', options);
    
    // Check cache first
    const cached = cacheService.get<PaginatedResponse<Article>>(cacheKey);
    if (cached) {
      logger.debug(`Cache hit for articles list: ${cacheKey}`);
      return cached;
    }

    try {
      const { 
        page = 1, 
        limit = 20,
        sourceId,
        categoryId,
        isRead,
        isFavorite,
        search,
        startDate,
        endDate
      } = options;

      const offset = (page - 1) * limit;
      
      // Build WHERE clause
      const conditions: string[] = [];
      const params: any = {};

      if (sourceId !== undefined) {
        conditions.push('a.source_id = @sourceId');
        params.sourceId = sourceId;
      }

      if (categoryId !== undefined) {
        conditions.push('s.category_id = @categoryId');
        params.categoryId = categoryId;
      }

      if (isRead !== undefined) {
        conditions.push('a.is_read = @isRead');
        params.isRead = isRead ? 1 : 0;
      }

      if (isFavorite !== undefined) {
        conditions.push('a.is_favorite = @isFavorite');
        params.isFavorite = isFavorite ? 1 : 0;
      }

      if (search) {
        conditions.push('(a.title LIKE @search OR a.summary LIKE @search OR a.excerpt LIKE @search)');
        params.search = `%${search}%`;
      }

      if (startDate) {
        conditions.push('a.published_date >= @startDate');
        params.startDate = startDate.toISOString();
      }

      if (endDate) {
        conditions.push('a.published_date <= @endDate');
        params.endDate = endDate.toISOString();
      }

      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      // Count total
      const countStmt = this.getDb().prepare(`
        SELECT COUNT(*) as total 
        FROM articles a
        LEFT JOIN sources s ON a.source_id = s.id
        ${whereClause}
      `);
      
      const { total } = countStmt.get(params) as { total: number };

      // Get paginated results - LIMIT content size
      const stmt = this.getDb().prepare(`
        SELECT 
          a.id, a.title, a.summary, a.description, a.excerpt, a.image_url, a.url, 
          a.author, a.published_date, a.source_id, a.is_read, a.is_favorite, 
          a.is_archived, a.read_at, a.favorited_at, a.created_at, a.updated_at,
          -- Limit content size for list view
          CASE 
            WHEN LENGTH(a.content) > 50000 THEN SUBSTR(a.content, 1, 50000) || '...'
            ELSE a.content
          END as content,
          s.name as source_name, 
          s.url as source_url,
          s.category_id,
          c.name as category_name,
          c.color as category_color
        FROM articles a
        LEFT JOIN sources s ON a.source_id = s.id
        LEFT JOIN categories c ON s.category_id = c.id
        ${whereClause}
        ORDER BY a.published_date DESC, a.created_at DESC
        LIMIT @limit OFFSET @offset
      `);

      const rows = stmt.all({ ...params, limit, offset });
      const articles = rows.map(row => this.mapRowToArticle(row));

      const result = {
        data: articles,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      };

      // Cache the result
      cacheService.set(cacheKey, result, CACHE_TTL.LIST);
      
      return result;
    } catch (error) {
      throw new DatabaseError('Failed to find articles', error);
    }
  }

  // Update article
  update(id: number, updates: Partial<Article>): Article | null {
    try {
      const setClauses: string[] = [];
      const params: any = { id };

      if ('isRead' in updates) {
        setClauses.push('is_read = @isRead');
        params.isRead = updates.isRead ? 1 : 0;
        if (updates.isRead) {
          setClauses.push('read_at = CURRENT_TIMESTAMP');
        }
      }

      if ('isFavorite' in updates) {
        setClauses.push('is_favorite = @isFavorite');
        params.isFavorite = updates.isFavorite ? 1 : 0;
        if (updates.isFavorite) {
          setClauses.push('favorited_at = CURRENT_TIMESTAMP');
        }
      }

      if ('isArchived' in updates) {
        setClauses.push('is_archived = @isArchived');
        params.isArchived = updates.isArchived ? 1 : 0;
      }

      if (setClauses.length === 0) {
        return this.findById(id);
      }

      const stmt = this.getDb().prepare(`
        UPDATE articles 
        SET ${setClauses.join(', ')}
        WHERE id = @id
      `);

      stmt.run(params);
      
      // Invalidate caches
      cacheService.delete(`article:${id}`);
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return this.findById(id);
    } catch (error) {
      throw new DatabaseError('Failed to update article', error);
    }
  }

  // Get article statistics - CACHED
  getStats(): { total: number; unread: number; favorites: number; sources: number } {
    const cacheKey = 'articles:stats';
    
    // Check cache first
    const cached = cacheService.get<any>(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      const stats = this.getDb().prepare(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN is_read = 0 THEN 1 ELSE 0 END) as unread,
          SUM(CASE WHEN is_favorite = 1 THEN 1 ELSE 0 END) as favorites,
          COUNT(DISTINCT source_id) as sources
        FROM articles
      `).get() as any;

      const result = {
        total: stats.total || 0,
        unread: stats.unread || 0,
        favorites: stats.favorites || 0,
        sources: stats.sources || 0
      };

      // Cache the result
      cacheService.set(cacheKey, result, CACHE_TTL.STATS);
      
      return result;
    } catch (error) {
      throw new DatabaseError('Failed to get article stats', error);
    }
  }

  // Find article by URL
  findByUrl(url: string): Article | null {
    try {
      const stmt = this.getDb().prepare(`
        SELECT 
          a.*, 
          s.name as source_name, 
          s.url as source_url,
          s.category_id,
          c.name as category_name,
          c.color as category_color
        FROM articles a
        LEFT JOIN sources s ON a.source_id = s.id
        LEFT JOIN categories c ON s.category_id = c.id
        WHERE a.url = ?
      `);

      const row = stmt.get(url);
      return row ? this.mapRowToArticle(row) : null;
    } catch (error) {
      throw new DatabaseError('Failed to find article by URL', error);
    }
  }

  // Delete article
  delete(id: number): boolean {
    try {
      const stmt = this.getDb().prepare('DELETE FROM articles WHERE id = ?');
      const info = stmt.run(id);
      
      // Invalidate caches
      cacheService.delete(`article:${id}`);
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return info.changes > 0;
    } catch (error) {
      throw new DatabaseError('Failed to delete article', error);
    }
  }

  // Bulk create with content size limitation
  bulkCreate(articles: Omit<Article, 'id' | 'createdAt' | 'updatedAt'>[]): number {
    try {
      const stmt = this.getDb().prepare(`
        INSERT INTO articles (
          title, content, summary, description, excerpt, image_url, url, author, published_date,
          source_id, is_read, is_favorite, is_archived
        ) VALUES (
          @title, @content, @summary, @description, @excerpt, @imageUrl, @url, @author, @publishedDate,
          @sourceId, @isRead, @isFavorite, @isArchived
        )
      `);

      const insertMany = this.getDb().transaction((articles) => {
        let inserted = 0;
        for (const article of articles) {
          try {
            // Limit content size to 100KB
            let content = article.content || null;
            if (content && content.length > 100000) {
              logger.warn(`Truncating large article content: ${article.title} (${content.length} chars)`);
              content = content.substring(0, 100000) + '\n\n[Contenu tronqué]';
            }

            stmt.run({
              title: article.title,
              content,
              summary: article.summary || null,
              description: article.description || null,
              excerpt: article.excerpt || null,
              imageUrl: article.imageUrl || null,
              url: article.url,
              author: article.author || null,
              publishedDate: article.publishedDate ? article.publishedDate.toISOString() : null,
              sourceId: article.sourceId,
              isRead: article.isRead ? 1 : 0,
              isFavorite: article.isFavorite ? 1 : 0,
              isArchived: article.isArchived ? 1 : 0
            });
            inserted++;
          } catch (error) {
            // Skip duplicates (UNIQUE constraint on URL)
            if (!(error as Error).message.includes('UNIQUE constraint')) {
              throw error;
            }
          }
        }
        return inserted;
      });

      const result = insertMany(articles);
      
      // Invalidate caches
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return result;
    } catch (error) {
      throw new DatabaseError('Failed to bulk create articles', error);
    }
  }

  // Delete multiple articles
  deleteMany(ids: number[]): number {
    try {
      if (ids.length === 0) return 0;
      
      const placeholders = ids.map(() => '?').join(',');
      const stmt = this.getDb().prepare(`DELETE FROM articles WHERE id IN (${placeholders})`);
      const info = stmt.run(...ids);
      
      // Invalidate caches
      ids.forEach(id => cacheService.delete(`article:${id}`));
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return info.changes;
    } catch (error) {
      throw new DatabaseError('Failed to delete multiple articles', error);
    }
  }

  // Delete all articles (with optional filters)
  deleteAll(filters?: { sourceId?: number; isRead?: boolean }): number {
    try {
      let query = 'DELETE FROM articles WHERE 1=1';
      const params: any[] = [];

      if (filters?.sourceId) {
        query += ' AND source_id = ?';
        params.push(filters.sourceId);
      }

      if (filters?.isRead !== undefined) {
        query += ' AND is_read = ?';
        params.push(filters.isRead ? 1 : 0);
      }

      const stmt = this.getDb().prepare(query);
      const info = stmt.run(...params);
      
      // Invalidate all caches
      cacheService.invalidatePattern(`article:.*`);
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return info.changes;
    } catch (error) {
      throw new DatabaseError('Failed to delete all articles', error);
    }
  }

  // Delete old articles (older than specified days)
  deleteOldArticles(daysOld: number = 15): number {
    try {
      const stmt = this.getDb().prepare(`
        DELETE FROM articles 
        WHERE created_at < datetime('now', '-' || ? || ' days')
        AND is_favorite = 0
      `);
      const info = stmt.run(daysOld);
      
      // Invalidate caches
      cacheService.invalidatePattern(`article:.*`);
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return info.changes;
    } catch (error) {
      throw new DatabaseError('Failed to delete old articles', error);
    }
  }

  // Update article content (for sync updates)
  updateContent(id: number, updates: Partial<Article>): Article | null {
    try {
      const setClauses: string[] = [];
      const params: any = { id };

      if ('title' in updates) {
        setClauses.push('title = @title');
        params.title = updates.title;
      }

      if ('content' in updates) {
        setClauses.push('content = @content');
        params.content = updates.content || null;
      }

      if ('summary' in updates) {
        setClauses.push('summary = @summary');
        params.summary = updates.summary || null;
      }

      if ('description' in updates) {
        setClauses.push('description = @description');
        params.description = updates.description || null;
      }

      if ('excerpt' in updates) {
        setClauses.push('excerpt = @excerpt');
        params.excerpt = updates.excerpt || null;
      }

      if ('imageUrl' in updates) {
        setClauses.push('image_url = @imageUrl');
        params.imageUrl = updates.imageUrl || null;
      }

      if ('publishedDate' in updates) {
        setClauses.push('published_date = @publishedDate');
        params.publishedDate = updates.publishedDate ? updates.publishedDate.toISOString() : null;
      }

      if (setClauses.length === 0) {
        return this.findById(id);
      }

      const stmt = this.getDb().prepare(`
        UPDATE articles 
        SET ${setClauses.join(', ')}, updated_at = CURRENT_TIMESTAMP
        WHERE id = @id
      `);

      stmt.run(params);
      
      // Invalidate caches
      cacheService.delete(`article:${id}`);
      cacheService.invalidatePattern(`articles:list:.*`);
      cacheService.delete('articles:stats');
      
      return this.findById(id);
    } catch (error) {
      throw new DatabaseError('Failed to update article content', error);
    }
  }

  // Find duplicate articles by URL
  findDuplicatesByUrl(sourceId?: number): Article[][] {
    try {
      let query = `
        SELECT url, COUNT(*) as count
        FROM articles
        WHERE 1=1
      `;
      const params: any[] = [];

      if (sourceId) {
        query += ' AND source_id = ?';
        params.push(sourceId);
      }

      query += ' GROUP BY url HAVING count > 1';

      const duplicateUrls = this.getDb().prepare(query).all(...params) as { url: string }[];
      const duplicateGroups: Article[][] = [];

      for (const { url } of duplicateUrls) {
        const stmt = this.getDb().prepare(`
          SELECT 
            a.*, 
            s.name as source_name, 
            s.url as source_url,
            s.category_id,
            c.name as category_name,
            c.color as category_color
          FROM articles a
          LEFT JOIN sources s ON a.source_id = s.id
          LEFT JOIN categories c ON s.category_id = c.id
          WHERE a.url = ?
          ORDER BY a.created_at DESC
        `);

        const articles = stmt.all(url).map(row => this.mapRowToArticle(row));
        if (articles.length > 1) {
          duplicateGroups.push(articles);
        }
      }

      return duplicateGroups;
    } catch (error) {
      throw new DatabaseError('Failed to find duplicate articles', error);
    }
  }

  // Helper method to map database row to Article object
  private mapRowToArticle(row: any): Article {
    return {
      id: row.id,
      title: row.title,
      content: row.content || undefined,
      summary: row.summary || undefined,
      description: row.description || undefined,
      excerpt: row.excerpt || undefined,
      imageUrl: row.image_url || undefined,
      url: row.url,
      author: row.author || undefined,
      publishedDate: row.published_date ? new Date(row.published_date) : undefined,
      sourceId: row.source_id,
      source: row.source_name ? {
        id: row.source_id,
        name: row.source_name,
        url: row.source_url,
        categoryId: row.category_id,
        category: row.category_name ? {
          id: row.category_id,
          name: row.category_name,
          color: row.category_color
        } as any : undefined
      } as any : undefined,
      isRead: Boolean(row.is_read),
      isFavorite: Boolean(row.is_favorite),
      isArchived: Boolean(row.is_archived),
      readAt: row.read_at ? new Date(row.read_at) : undefined,
      favoritedAt: row.favorited_at ? new Date(row.favorited_at) : undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at)
    };
  }
}

// Export singleton instance
export const cachedArticleModel = new CachedArticleModel();